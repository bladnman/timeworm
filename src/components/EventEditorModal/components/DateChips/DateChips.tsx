/**
 * Date Chips
 *
 * Smart date editor with auto-generated display format.
 * Shows human-readable dates derived from ISO dates.
 * Simplified: just Start and optional End dates.
 */

import { useState, useEffect, useCallback } from 'react';
import classNames from 'classnames';
import { formatDateRangeDisplay } from '../../../../utils/dateUtils';
import styles from './DateChips.module.css';

interface DateChipsProps {
  dateStart: string;
  dateEnd: string;
  dateDisplay: string;
  onDateStartChange: (value: string) => void;
  onDateEndChange: (value: string) => void;
  onDateDisplayChange: (value: string) => void;
  errors?: Record<string, string>;
}

export const DateChips: React.FC<DateChipsProps> = ({
  dateStart,
  dateEnd,
  dateDisplay,
  onDateStartChange,
  onDateEndChange,
  onDateDisplayChange,
  errors,
}) => {
  const [editingField, setEditingField] = useState<string | null>(null);
  const [hasCustomDisplay, setHasCustomDisplay] = useState(false);

  // Auto-generate display date from start/end when not custom
  const autoGenerateDisplay = useCallback(() => {
    if (!hasCustomDisplay && dateStart) {
      const generated = formatDateRangeDisplay(dateStart, dateEnd || undefined);
      if (generated !== dateDisplay) {
        onDateDisplayChange(generated);
      }
    }
  }, [dateStart, dateEnd, hasCustomDisplay, dateDisplay, onDateDisplayChange]);

  // Update display when dates change (unless user has customized it)
  useEffect(() => {
    autoGenerateDisplay();
  }, [autoGenerateDisplay]);

  // Check if the current display matches what we'd auto-generate
  const generatedDisplay = dateStart ? formatDateRangeDisplay(dateStart, dateEnd || undefined) : '';
  const isDisplayCustom = dateDisplay && dateDisplay !== generatedDisplay;

  const handleDisplayChange = (value: string) => {
    onDateDisplayChange(value);
    // If user clears the field or it matches generated, reset to auto mode
    if (!value || value === generatedDisplay) {
      setHasCustomDisplay(false);
    } else {
      setHasCustomDisplay(true);
    }
  };

  const handleDisplayBlur = () => {
    setEditingField(null);
    // If display is empty, regenerate it
    if (!dateDisplay && dateStart) {
      setHasCustomDisplay(false);
      autoGenerateDisplay();
    }
  };

  return (
    <div className={styles.container}>
      {/* Display Date - Shows human-readable format */}
      <div className={styles.displaySection}>
        {editingField === 'display' ? (
          <input
            type="text"
            className={styles.displayInput}
            value={dateDisplay}
            onChange={(e) => handleDisplayChange(e.target.value)}
            onBlur={handleDisplayBlur}
            onKeyDown={(e) => e.key === 'Enter' && setEditingField(null)}
            autoFocus
            placeholder="e.g., June 12, 1817"
          />
        ) : (
          <button
            className={styles.displayButton}
            onClick={() => setEditingField('display')}
            title={isDisplayCustom ? 'Custom display (click to edit)' : 'Auto-generated (click to customize)'}
          >
            {dateDisplay || 'Set date'}
            {isDisplayCustom && <span className={styles.customBadge}>custom</span>}
          </button>
        )}
      </div>

      {/* ISO Date Inputs */}
      <div className={styles.isoSection}>
        {/* Start Date */}
        <div className={styles.chipGroup}>
          <label className={styles.chipLabel}>Start</label>
          {editingField === 'start' ? (
            <input
              type="text"
              className={classNames(styles.chipInput, {
                [styles.chipInputError]: errors?.date_start,
              })}
              value={dateStart}
              onChange={(e) => onDateStartChange(e.target.value)}
              onBlur={() => setEditingField(null)}
              onKeyDown={(e) => e.key === 'Enter' && setEditingField(null)}
              autoFocus
              placeholder="YYYY-MM-DD"
            />
          ) : (
            <button
              className={classNames(styles.chip, {
                [styles.chipError]: errors?.date_start,
              })}
              onClick={() => setEditingField('start')}
            >
              {dateStart || 'Required'}
            </button>
          )}
          {errors?.date_start && (
            <span className={styles.error}>{errors.date_start}</span>
          )}
        </div>

        {/* End Date */}
        <div className={styles.chipGroup}>
          <label className={styles.chipLabel}>End</label>
          {editingField === 'end' ? (
            <input
              type="text"
              className={styles.chipInput}
              value={dateEnd}
              onChange={(e) => onDateEndChange(e.target.value)}
              onBlur={() => setEditingField(null)}
              onKeyDown={(e) => e.key === 'Enter' && setEditingField(null)}
              autoFocus
              placeholder="YYYY-MM-DD"
            />
          ) : (
            <button
              className={classNames(styles.chip, styles.chipOptional)}
              onClick={() => setEditingField('end')}
            >
              {dateEnd || 'Optional'}
            </button>
          )}
        </div>
      </div>
    </div>
  );
};
